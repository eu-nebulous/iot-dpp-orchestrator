package eut.nebulouscloud.iot_dpp;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import org.apache.activemq.artemis.api.core.QueueConfiguration;
import org.apache.activemq.artemis.core.config.ClusterConnectionConfiguration;
import org.apache.activemq.artemis.core.config.Configuration;
import org.apache.activemq.artemis.core.config.CoreAddressConfiguration;
import org.apache.activemq.artemis.core.config.DivertConfiguration;
import org.apache.activemq.artemis.core.config.TransformerConfiguration;
import org.apache.activemq.artemis.core.config.impl.ConfigurationImpl;
import org.apache.activemq.artemis.core.security.CheckType;
import org.apache.activemq.artemis.core.security.Role;
import org.apache.activemq.artemis.core.server.cluster.impl.MessageLoadBalancingType;
import org.apache.activemq.artemis.core.server.embedded.EmbeddedActiveMQ;
import org.apache.activemq.artemis.core.settings.impl.AddressSettings;
import org.apache.activemq.artemis.spi.core.security.ActiveMQSecurityManager;
import org.apache.qpid.protonj2.client.ClientOptions;
import org.apache.qpid.protonj2.client.Delivery;
import org.apache.qpid.protonj2.client.DeliveryMode;
import org.apache.qpid.protonj2.client.Receiver;
import org.eclipse.paho.client.mqttv3.IMqttClient;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.MqttCallback;
import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.eclipse.paho.client.mqttv3.MqttSecurityException;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.databind.ObjectMapper;

import eut.nebulouscloud.iot_dpp.GroupIDExtractionParameters.GroupIDExpressionSource;
import eut.nebulouscloud.iot_dpp.monitoring.EMSMessageLifecycleMonitoringPlugin;
import eut.nebulouscloud.iot_dpp.monitoring.MessageLifecycleMonitoringPlugin;
import eut.nebulouscloud.iot_dpp.monitoring.events.MessageAcknowledgedEvent;
import eut.nebulouscloud.iot_dpp.monitoring.events.MessageDeliveredEvent;
import eut.nebulouscloud.iot_dpp.monitoring.events.MessageLifecycleEvent;
import eut.nebulouscloud.iot_dpp.monitoring.events.MessagePublishedEvent;


/**
 * Tests that an IoT pipeline can be created manually (creating the necessary DivertConfigurations)
 */
class ManualIoTPipelineCreationTest {
	ObjectMapper om = new ObjectMapper();
	static Logger LOGGER = LoggerFactory.getLogger(ManualIoTPipelineCreationTest.class);

	/**
	 * Creates a local ActiveMQ server listening at localhost:61616. The server
	 * accepts requests from any user. Configures the MessageMonitoringPluging and
	 * sets it to store generated events in the provided events list
	 * 
	 * @param events A list that will contain all the events generated by the
	 *               MessageMonitoringPluging
	 * @return the created MessageMonitoringPluging instance.
	 * @throws Exception
	 */
	private EmbeddedActiveMQ createActiveMQBroker(String nodeName, String configPath, int port,
			List<Integer> otherServers) throws Exception {
		Configuration config = new ConfigurationImpl();
		config.setName(nodeName);
		String foldersRoot = "data/" + new Date().getTime() + "/data_" + port;
		config.setBindingsDirectory(foldersRoot + "/bindings");
		config.setJournalDirectory(foldersRoot + "/journal");
		config.setJournalRetentionDirectory(foldersRoot + "/journalRetention");
		config.setLargeMessagesDirectory(foldersRoot + "/lm");
		config.setNodeManagerLockDirectory(foldersRoot + "/nodeManagerLock");
		config.setPagingDirectory(foldersRoot + "/paging");
		config.addConnectorConfiguration("serverAt" + port + "Connector", "tcp://localhost:" + port);
		config.addAcceptorConfiguration("netty", "tcp://localhost:" + port);

		/*
		 * CoreAddressConfiguration address = new CoreAddressConfiguration();
		 * QueueConfiguration queueC = new QueueConfiguration();
		 * queueC.setName("neb.test-topic"); address.setName("neb");
		 * 
		 * address.addQueueConfig(queueC); config.addAddressConfiguration(address);
		 * 
		 * AddressSettings addrS = new AddressSettings();
		 * addrS.setAutoCreateQueues(false);
		 * 
		 * //https://activemq.apache.org/components/artemis/documentation/latest/address
		 * -settings.html#address-settings config.addAddressSetting("neb.#",addrS);
		 */

		TransformerConfiguration divertTransformerConfig = new TransformerConfiguration();
		divertTransformerConfig.setClassName(GroupIDAnnotationDivertTransfomer.class.getName());
		divertTransformerConfig.setProperties(Map.of("NEB_IOT_DPP_GROUPID_EXTRACTION_CONFIG_PATH", configPath));

		DivertConfiguration divertSrctoA = new DivertConfiguration();
		divertSrctoA.setName("divertSrctoA");
		divertSrctoA.setAddress("neb.src");
		divertSrctoA.setExclusive(false);
		divertSrctoA.setForwardingAddress("neb.step_A_input");
		divertSrctoA.setTransformerConfiguration(divertTransformerConfig);
		//divertAtoB.setFilterString("*");
		config.addDivertConfiguration(divertSrctoA);

		DivertConfiguration divertAtoB = new DivertConfiguration();
		divertAtoB.setName("divertAtoB");
		divertAtoB.setAddress("neb.step_A_output");
		divertAtoB.setExclusive(false);
		divertAtoB.setForwardingAddress("neb.step_B_input");
		divertAtoB.setTransformerConfiguration(divertTransformerConfig);
		config.addDivertConfiguration(divertAtoB);

		ClusterConnectionConfiguration cluster = new ClusterConnectionConfiguration();
		cluster.setAddress("");
		cluster.setConnectorName("serverAt" + port + "Connector");
		cluster.setName("my-cluster");
		cluster.setAllowDirectConnectionsOnly(false);
		cluster.setMessageLoadBalancingType(MessageLoadBalancingType.ON_DEMAND);
		cluster.setRetryInterval(100);
		config.setClusterConfigurations(List.of(cluster));
		if (otherServers != null) {
			for (Integer otherPort : otherServers) {
				cluster.setStaticConnectors(List.of("serverAt" + otherPort + "Connector"));
				config.addConnectorConfiguration("serverAt" + otherPort + "Connector", "tcp://localhost:" + otherPort);
			}
		}
		
		MessageGroupIDAnnotationPlugin p = new MessageGroupIDAnnotationPlugin();
		p.init(Map.of(MessageGroupIDAnotator.GROUP_ID_EXTRACTION_CONFIG_PATH_ENV_VAR,configPath));
		config.getBrokerMessagePlugins().add(p);
		EmbeddedActiveMQ server = new EmbeddedActiveMQ();
		server.setSecurityManager(new ActiveMQSecurityManager() {
			@Override
			public boolean validateUserAndRole(String user, String password, Set<Role> roles, CheckType checkType) {
				return true;
			}

			@Override
			public boolean validateUser(String user, String password) {
				return true;
			}
		});
		server.setConfiguration(config);
		server.start();
		return server;
	}

	
	private EmbeddedActiveMQ createActiveMQBroker(String nodeName, String configPath, int port) throws Exception {
		return createActiveMQBroker(nodeName, configPath, port, null);
	}

	private IMqttClient buildWorker(String brokerURL, String clientId, String inputTopic, String outputTopic,
			List<MessageReceptionRecord> messages) throws Exception {
		IMqttClient consumer = new MqttClient("tcp://" + brokerURL, clientId);
		consumer.setCallback(new MqttCallback() {

			@Override
			public void messageArrived(String topic, MqttMessage message) throws Exception {
				messages.add(new MessageReceptionRecord(consumer.getClientId(), topic,
						om.readValue(new String(message.getPayload()), TestMessage.class)));
				LOGGER.info("Worker "+consumer.getClientId()+" messageArrived");
				consumer.publish(outputTopic, message.getPayload(), 2, false);

			}

			@Override
			public void deliveryComplete(IMqttDeliveryToken token) {
			}

			@Override
			public void connectionLost(Throwable cause) {
				LOGGER.error("Worker "+consumer.getClientId() + " connectionLost", cause);
			}
		});
		MqttConnectOptions opts = new MqttConnectOptions();
		// opts.setUserName("artemis");
		// opts.setPassword("artemis".toCharArray());
		opts.setCleanSession(false);

		consumer.connect(opts);
		consumer.subscribe(inputTopic, 2);
		return consumer;
	}

	/**
	 * Test message monitoring plugin when MQTT clients are interacting with the
	 * ActiveMQ broker.
	 * 
	 * @throws Exception
	 */
	@Test
	void MQTTTestSingleNode() throws Exception {

		/**
		 * Create a local ActiveMQ server
		 */
		// String testTopic = ;
		int brokerPort = 6169;
		String brokerURL = "localhost:" + brokerPort;
		// localhost:1883"
		Map<String, GroupIDExtractionParameters> map = new HashMap<String, GroupIDExtractionParameters>();
		map.put("neb.step_A_input", new GroupIDExtractionParameters(GroupIDExpressionSource.BODY_JSON, "fieldA"));
		map.put("neb.step_B_input", new GroupIDExtractionParameters(GroupIDExpressionSource.BODY_JSON, "fieldB"));

		Path tempPath = Files.createTempFile("GroupIDExtractionParameters", ".json");
		Files.write(tempPath, om.writeValueAsBytes(map));
		EmbeddedActiveMQ broker = null;
		try {

			broker = createActiveMQBroker("test-server", tempPath.toString(), brokerPort);

			List<MessageReceptionRecord> messages = Collections
					.synchronizedList(new LinkedList<MessageReceptionRecord>());
			IMqttClient stepAWorker1 = buildWorker(brokerURL, "step_A_worker_1", "$share/all/neb.step_A_input","neb.step_A_output",
					messages);
			IMqttClient stepAWorker2 = buildWorker(brokerURL, "step_A_worker_2", "$share/all/neb.step_A_input","neb.step_A_output",
					messages);
			IMqttClient stepBWorker1 = buildWorker(brokerURL, "step_B_worker_1", "$share/all/neb.step_B_input","neb.step_B_output",
					messages);
			IMqttClient stepBWorker2 = buildWorker(brokerURL, "step_B_worker_2", "$share/all/neb.step_B_input","neb.step_B_output",
					messages);


			/**
			 * Publish a message to the topic
			 */
			IMqttClient publisher = new MqttClient("tcp://" + brokerURL, "publisher");
			MqttConnectOptions connOpts = new MqttConnectOptions();
			connOpts.setUserName("artemis");
			connOpts.setPassword("artemis".toCharArray());

			publisher.connect(connOpts);

			int messagesCount = 5;
			Random rand = new Random();
			for (int i = 0; i < messagesCount; i++) {
				//MqttMessage message = new MqttMessage("hola from publisher".getBytes());
				//message.setQos(2);
				//publisherBrokerA.publish(testTopic, message);
				
				TestMessage payload = new TestMessage(i, rand.nextInt(1, 10), rand.nextInt(1, 10));
				MqttMessage message = new MqttMessage(om.writeValueAsString(payload).getBytes());
				message.setQos(2);
				publisher.publish("neb.src", message);				
				Thread.sleep(1);
			}
			Thread.sleep(1000);
			for (String step : List.of("A", "B")) {
				List<MessageReceptionRecord> stepInputMessages = messages.stream()
						.filter(m -> m.consumerId.startsWith("step_" + step)).toList();
				assertEquals(messagesCount, stepInputMessages.size());

				List<Integer> fieldWithGroupingKeyValues = stepInputMessages.stream().map(m -> m.payload.getField(step))
						.distinct().toList();
				for (Integer groupingKeyValue : fieldWithGroupingKeyValues) {
					assertEquals(1, stepInputMessages.stream().filter(m -> m.payload.getField(step) == groupingKeyValue)
							.map(m -> m.consumerId).distinct().count());
				}

			}

		} finally {
			try {
				broker.stop();
			} catch (Exception e) {
			}
		}

	}

}
