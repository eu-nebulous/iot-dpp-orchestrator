package eut.nebulouscloud.iot_dpp;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import org.apache.activemq.artemis.core.config.ClusterConnectionConfiguration;
import org.apache.activemq.artemis.core.config.Configuration;
import org.apache.activemq.artemis.core.config.impl.ConfigurationImpl;
import org.apache.activemq.artemis.core.security.CheckType;
import org.apache.activemq.artemis.core.security.Role;
import org.apache.activemq.artemis.core.server.cluster.impl.MessageLoadBalancingType;
import org.apache.activemq.artemis.core.server.embedded.EmbeddedActiveMQ;
import org.apache.activemq.artemis.spi.core.security.ActiveMQSecurityManager;
import org.apache.qpid.protonj2.client.ClientOptions;
import org.apache.qpid.protonj2.client.Delivery;
import org.apache.qpid.protonj2.client.DeliveryMode;
import org.apache.qpid.protonj2.client.Receiver;
import org.eclipse.paho.client.mqttv3.IMqttClient;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.MqttCallback;
import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import eut.nebulouscloud.iot_dpp.monitoring.EMSQueuesMonitoringPlugin;
import eut.nebulouscloud.iot_dpp.monitoring.EMSQueuesMonitoringPluginConsumer;
import eut.nebulouscloud.iot_dpp.monitoring.MessageLifecycleMonitoringPlugin;
import eut.nebulouscloud.iot_dpp.monitoring.QueuesMonitoringMessage;
import eut.nebulouscloud.iot_dpp.monitoring.QueuesMonitoringPlugin;
import eut.nebulouscloud.iot_dpp.monitoring.QueuesMonitoringPlugin.QueuesMonitoringPluginConsumer;
import eut.nebulouscloud.iot_dpp.monitoring.QueuesMonitoringProcess;
import eut.nebulouscloud.iot_dpp.monitoring.events.MessageAcknowledgedEvent;
import eut.nebulouscloud.iot_dpp.monitoring.events.MessageDeliveredEvent;
import eut.nebulouscloud.iot_dpp.monitoring.events.MessageLifecycleEvent;
import eut.nebulouscloud.iot_dpp.monitoring.events.MessagePublishedEvent;

/**
 * Test the correct functionaltiy of QueuesMonitoringPlugin
 */
class QueuesMonitoringPluginTest {

	static Logger LOGGER = LoggerFactory.getLogger(QueuesMonitoringPluginTest.class);
	static int QueuesMonitoringProcesQueryIntervalSeconds = 3;
	/**
	 * Creates a local ActiveMQ server listening at localhost:61616. The server
	 * accepts requests from any user. Configures the MessageMonitoringPluging and
	 * sets it to store generated events in the provided events list
	 * 
	 * @param events A list that will contain all the events generated by the
	 *               MessageMonitoringPluging
	 * @return the created MessageMonitoringPluging instance.
	 * @throws Exception
	 */
	private EmbeddedActiveMQ createActiveMQBroker(String nodeName, int port, List<Integer> otherServers,
			List<List<QueuesMonitoringMessage>> result) throws Exception {
		Configuration config = new ConfigurationImpl();
		config.setName(nodeName);
		String foldersRoot = "data/" + new Date().getTime() + "/data_" + port;
		config.setBindingsDirectory(foldersRoot + "/bindings");
		config.setJournalDirectory(foldersRoot + "/journal");
		config.setJournalRetentionDirectory(foldersRoot + "/journalRetention");
		config.setLargeMessagesDirectory(foldersRoot + "/lm");
		config.setNodeManagerLockDirectory(foldersRoot + "/nodeManagerLock");
		config.setPagingDirectory(foldersRoot + "/paging");
		config.addConnectorConfiguration("serverAt" + port + "Connector", "tcp://localhost:" + port);
		config.addAcceptorConfiguration("netty", "tcp://localhost:" + port);
		
		
		ClusterConnectionConfiguration cluster = new ClusterConnectionConfiguration();
		cluster.setAddress("");
		cluster.setConnectorName("serverAt" + port + "Connector");
		cluster.setName("my-cluster");
		cluster.setAllowDirectConnectionsOnly(false);
		cluster.setMessageLoadBalancingType(MessageLoadBalancingType.ON_DEMAND);
		cluster.setRetryInterval(100);
		config.setClusterConfigurations(List.of(cluster));
		if (otherServers != null) {
			for (Integer otherPort : otherServers) {
				cluster.setStaticConnectors(List.of("serverAt" + otherPort + "Connector"));
				config.addConnectorConfiguration("serverAt" + otherPort + "Connector", "tcp://localhost:" + otherPort);
			}
		}
		QueuesMonitoringPlugin plugin = new QueuesMonitoringPlugin();
		plugin.init(Map.of(
				"monitored_topic_prefix","consumer.neb","local_activemq_url","tcp://localhost:"+port,"query_interval_seconds",""+QueuesMonitoringProcesQueryIntervalSeconds,"local_activemq_user","artemis","local_activemq_password","artemis"));
		
		config.getBrokerMessagePlugins().add(plugin);
		plugin.registered(null);
		plugin.process.consumer = new QueuesMonitoringPluginConsumer() {

			@Override
			public void consume(List<QueuesMonitoringMessage> messages) {
				result.add(messages);

			}
		};
		/*EMSQueuesMonitoringPlugin plugin = new EMSQueuesMonitoringPlugin();
		plugin.init(Map.of("monitored_topic_prefix",".neb","local_activemq_url","tcp://localhost:"+port,"query_interval_seconds",""+QueuesMonitoringProcesQueryIntervalSeconds));
		*/
		//
		EmbeddedActiveMQ server = new EmbeddedActiveMQ();
		server.setSecurityManager(new ActiveMQSecurityManager() {
			@Override
			public boolean validateUserAndRole(String user, String password, Set<Role> roles, CheckType checkType) {
				return true;
			}

			@Override
			public boolean validateUser(String user, String password) {
				return true;
			}
		});
		server.setConfiguration(config);
		server.start();
		return server;
	}

	private EmbeddedActiveMQ createActiveMQBroker(String nodeName, int port, List<List<QueuesMonitoringMessage>> result)
			throws Exception {
		return createActiveMQBroker(nodeName, port, null, result);
	}

	/**
	 * Test message monitoring plugin when MQTT clients are interacting with the
	 * ActiveMQ broker.
	 * 
	 * @throws Exception
	 */
	@Test
	void MQTTTestSingleNode() throws Exception {

		/**
		 * Create a local ActiveMQ server
		 */

		EmbeddedActiveMQ broker = null;
		try {
			int port = 6661;
			List<List<QueuesMonitoringMessage>> result = new LinkedList<List<QueuesMonitoringMessage>>();
			broker = createActiveMQBroker("test-server",port, result);


			/**
			 * Create a persistent subscription on a topic. Close the consumer afterwards.
			 */
			String testTopic = "neb1";
			IMqttClient consumer = new MqttClient("tcp://localhost:"+port, "consumer");
			consumer.setCallback(new MqttCallback() {

				@Override
				public void messageArrived(String topic, MqttMessage message) throws Exception {
					LOGGER.info("messageArrived: " + topic + " " + new String(message.getPayload()));
				}

				@Override
				public void deliveryComplete(IMqttDeliveryToken token) {
				}

				@Override
				public void connectionLost(Throwable cause) {
					LOGGER.error("",cause);
				}
			});
			MqttConnectOptions opts = new MqttConnectOptions();
			opts.setCleanSession(false);
			/**
			 * Connect the consumer, subscribe and disconnect
			 */
			consumer.connect(opts);
			consumer.subscribe(testTopic, 2);
			consumer.disconnect();

			/**
			 * Publish some messages to the topic
			 */
			IMqttClient publisher = new MqttClient("tcp://localhost:"+port, "publisher");
			publisher.connect();
			
			
			int numMessages = 20;
			for (int i = 0; i < numMessages; i++) {
				Thread.sleep(10);
				MqttMessage message = new MqttMessage("hola".getBytes());
				message.setQos(2);
				publisher.publish(testTopic, message);
			}
			Thread.sleep(QueuesMonitoringProcesQueryIntervalSeconds*1000*3);
			
			assertTrue(result.size()>=2);
			assertTrue(result.stream().allMatch(r->r.size()==1)); //Only 1 topic is reported
			assertTrue(result.stream().allMatch(r->r.get(0).queue.endsWith(testTopic)));//The reported topic is the test topic
			for(int i=1;i<result.size();i++)
			{	
				assertTrue(result.get(i-1).get(0).maxMessageAge<result.get(i).get(0).maxMessageAge);
				assertTrue(result.get(i-1).get(0).messageCount<=result.get(i).get(0).messageCount);
			}
			assertEquals(numMessages,result.get(result.size()-1).get(0).messageCount);
			
			/**
			 * Reconnect the consumer. Messages shall be consumed
			 */
			consumer.connect(opts);
			
			Thread.sleep(QueuesMonitoringProcesQueryIntervalSeconds*1000*2);
			assertEquals(0,result.get(result.size()-1).get(0).messageCount);

		} finally {
			try {
				broker.stop();
			} catch (Exception e) {
			}
		}

	}

}
