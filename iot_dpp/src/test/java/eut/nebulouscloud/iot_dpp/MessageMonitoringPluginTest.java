package eut.nebulouscloud.iot_dpp;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import org.apache.activemq.artemis.core.config.ClusterConnectionConfiguration;
import org.apache.activemq.artemis.core.config.Configuration;
import org.apache.activemq.artemis.core.config.impl.ConfigurationImpl;
import org.apache.activemq.artemis.core.security.CheckType;
import org.apache.activemq.artemis.core.security.Role;
import org.apache.activemq.artemis.core.server.cluster.impl.MessageLoadBalancingType;
import org.apache.activemq.artemis.core.server.embedded.EmbeddedActiveMQ;
import org.apache.activemq.artemis.spi.core.security.ActiveMQSecurityManager;
import org.apache.qpid.protonj2.client.ClientOptions;
import org.apache.qpid.protonj2.client.Delivery;
import org.apache.qpid.protonj2.client.DeliveryMode;
import org.apache.qpid.protonj2.client.Receiver;
import org.eclipse.paho.client.mqttv3.IMqttClient;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.MqttCallback;
import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import eut.nebulouscloud.iot_dpp.monitoring.MessageLifecycleMonitoringPlugin;
import eut.nebulouscloud.iot_dpp.monitoring.events.MessageAcknowledgedEvent;
import eut.nebulouscloud.iot_dpp.monitoring.events.MessageDeliveredEvent;
import eut.nebulouscloud.iot_dpp.monitoring.events.MessageLifecycleEvent;
import eut.nebulouscloud.iot_dpp.monitoring.events.MessagePublishedEvent;

/**
 * Test the correct functionaltiy of MessageLifecycleMonitoringPlugin
 */
class MessageMonitoringPluginTest {

	static Logger LOGGER = LoggerFactory.getLogger(MessageMonitoringPluginTest.class);

	/**
	 * Creates a local ActiveMQ server listening at localhost:61616. The server
	 * accepts requests from any user. Configures the MessageMonitoringPluging and
	 * sets it to store generated events in the provided events list
	 * 
	 * @param events A list that will contain all the events generated by the
	 *               MessageMonitoringPluging
	 * @return the created MessageMonitoringPluging instance.
	 * @throws Exception
	 */
	private EmbeddedActiveMQ createActiveMQBroker(String nodeName, List<MessageLifecycleEvent> events, int port,
			List<Integer> otherServers) throws Exception {
		Configuration config = new ConfigurationImpl();
		config.setName(nodeName);
		String foldersRoot = "data/" + new Date().getTime() + "/data_" + port;
		config.setBindingsDirectory(foldersRoot + "/bindings");
		config.setJournalDirectory(foldersRoot + "/journal");
		config.setJournalRetentionDirectory(foldersRoot + "/journalRetention");
		config.setLargeMessagesDirectory(foldersRoot + "/lm");
		config.setNodeManagerLockDirectory(foldersRoot + "/nodeManagerLock");
		config.setPagingDirectory(foldersRoot + "/paging");
		config.addConnectorConfiguration("serverAt" + port + "Connector", "tcp://localhost:" + port);
		config.addAcceptorConfiguration("netty", "tcp://localhost:" + port);
		// config.setPersistenceEnabled(true);		
		
		
		ClusterConnectionConfiguration cluster = new ClusterConnectionConfiguration();
		cluster.setAddress("");
		cluster.setConnectorName("serverAt" + port + "Connector");
		cluster.setName("my-cluster");
		cluster.setAllowDirectConnectionsOnly(false);
		cluster.setMessageLoadBalancingType(MessageLoadBalancingType.ON_DEMAND);
		cluster.setRetryInterval(100);
		config.setClusterConfigurations(List.of(cluster));
		if (otherServers != null) {
			for (Integer otherPort : otherServers) {
				cluster.setStaticConnectors(List.of("serverAt" + otherPort + "Connector"));
				config.addConnectorConfiguration("serverAt" + otherPort + "Connector", "tcp://localhost:" + otherPort);
			}
		}
		MessageLifecycleMonitoringPlugin plugin = new MessageLifecycleMonitoringPlugin() {
			@Override
			protected void notifyEvent(MessageLifecycleEvent event) {
				events.add(event);
			}
		};

		config.getBrokerMessagePlugins().add(plugin);
		EmbeddedActiveMQ server = new EmbeddedActiveMQ();
		server.setSecurityManager(new ActiveMQSecurityManager() {
			@Override
			public boolean validateUserAndRole(String user, String password, Set<Role> roles, CheckType checkType) {
				return true;
			}

			@Override
			public boolean validateUser(String user, String password) {
				return true;
			}
		});
		server.setConfiguration(config);
		server.start();
		return server;
	}

	private EmbeddedActiveMQ createActiveMQBroker(String nodeName, List<MessageLifecycleEvent> events)
			throws Exception {
		return createActiveMQBroker(nodeName, events, 61616, null);
	}

	/**
	 * Test message monitoring plugin when MQTT clients are interacting with the
	 * ActiveMQ broker.
	 * 
	 * @throws Exception
	 */
	@Test
	void MQTTTestSingleNode() throws Exception {

		/**
		 * Create a local ActiveMQ server
		 */

		EmbeddedActiveMQ broker = null;
		try {
			List<MessageLifecycleEvent> raisedEvents = new LinkedList<MessageLifecycleEvent>();
			broker = createActiveMQBroker("test-server", raisedEvents);

			/**
			 * Create a persistent subscription on a topic. Close the consumer afterwards.
			 */
			String testTopic = "test-topic";
			IMqttClient consumer = new MqttClient("tcp://localhost:61616", "consumer");
			consumer.setCallback(new MqttCallback() {

				@Override
				public void messageArrived(String topic, MqttMessage message) throws Exception {
					LOGGER.info("messageArrived: " + topic + " " + new String(message.getPayload()));
				}

				@Override
				public void deliveryComplete(IMqttDeliveryToken token) {
				}

				@Override
				public void connectionLost(Throwable cause) {
				}
			});
			MqttConnectOptions opts = new MqttConnectOptions();
			opts.setCleanSession(false);
			consumer.connect(opts);
			consumer.subscribe(testTopic, 2);
			consumer.disconnect();

			/**
			 * Publish a message to the topic
			 */
			IMqttClient publisher = new MqttClient("tcp://localhost:61616", "publisher");
			publisher.connect();
			MqttMessage message = new MqttMessage("hola".getBytes());
			message.setQos(2);
			publisher.publish(testTopic, message);

			/**
			 * Wait some time and re-connect the consumer.
			 */
			Thread.sleep(1000);
			long reconnectTime = new Date().getTime();			
			consumer.connect(opts);			
			Thread.sleep(1000); // Give some time for consumer to receive messages

			/**
			 * Validate that the MessagePublishedMonitoringEvent,
			 * MessageDeliveredMonitoringEvent and MessageAcknowledgedMonitoringEvent are
			 * properly generated
			 */
			Optional<MessageLifecycleEvent> publishEventOpt = raisedEvents.stream()
					.filter(e -> e.getClass() == MessagePublishedEvent.class).findFirst();
			assertEquals(true, publishEventOpt.isPresent());
			MessagePublishedEvent publishEvent = (MessagePublishedEvent) publishEventOpt.get();

			Optional<MessageLifecycleEvent> deliverEventOpt = raisedEvents.stream()
					.filter(e -> e.getClass() == MessageDeliveredEvent.class).findFirst();
			assertEquals(true, deliverEventOpt.isPresent());
			MessageDeliveredEvent deliverEvent = (MessageDeliveredEvent) deliverEventOpt.get();

			Optional<MessageLifecycleEvent> ackEventOptional = raisedEvents.stream()
					.filter(e -> e.getClass() == MessageAcknowledgedEvent.class).findFirst();
			assertEquals(true, ackEventOptional.isPresent());
			MessageAcknowledgedEvent ackEvent = (MessageAcknowledgedEvent) ackEventOptional.get();

			assertEquals(publishEvent.messageAddress, deliverEvent.publishAddress);
			assertEquals(publishEvent.clientId, deliverEvent.publishClientId);
			assertEquals(publishEvent.messageId, deliverEvent.messageId);
			// assertEquals(publishEvent.messageSize, deliverEvent.messageSize);
			assertEquals(publishEvent.node, deliverEvent.publishNode);
			assertEquals(publishEvent.timestamp, deliverEvent.publishTimestamp);
			assertTrue(deliverEvent.timestamp > reconnectTime);
			assertEquals(publishEvent.messageId, ackEvent.messageId);
			assertEquals(ackEvent.deliverTimestamp, deliverEvent.timestamp);
			assertTrue(ackEvent.timestamp > reconnectTime);

		} finally {
			try {
				broker.stop();
			} catch (Exception e) {
			}
		}

	}

	/**
	 * Test message monitoring plugin when AMQP clients are interacting with the
	 * ActiveMQ broker.
	 * 
	 * @throws Exception
	 */
	@Test
	void AMQPTestSingleNode() throws Exception {

		EmbeddedActiveMQ broker = null;
		try {
			/**
			 * Create a local server
			 */
			List<MessageLifecycleEvent> raisedEvents = new LinkedList<MessageLifecycleEvent>();
			broker = createActiveMQBroker("test-broker", raisedEvents);
			/**
			 * Create a durable subscription on a topic. Close the receiver immediately.
			 */
			String address = "test-addr";
			org.apache.qpid.protonj2.client.Connection receiverConnection;
			Receiver receiver;
			{
				ClientOptions opts = new ClientOptions();
				opts.id("receiver");
				org.apache.qpid.protonj2.client.Client container = org.apache.qpid.protonj2.client.Client.create(opts);
				receiverConnection = container.connect("localhost", 61616).openFuture().get();
				org.apache.qpid.protonj2.client.ReceiverOptions options = new org.apache.qpid.protonj2.client.ReceiverOptions()
						.deliveryMode(DeliveryMode.AT_LEAST_ONCE).autoAccept(false).autoSettle(false);
				org.apache.qpid.protonj2.client.Session session = receiverConnection.openSession().openFuture().get();

				receiver = session.openDurableReceiver(address, "my-durable-sub", options);
				receiver.openFuture().get(10, TimeUnit.SECONDS);
				/* receiver.close(); */
				session.close();
				container.close();
			}

			/**
			 * Send some messages to the topic
			 */
			org.apache.qpid.protonj2.client.Sender sender;
			org.apache.qpid.protonj2.client.Connection senderConnection;
			{
				ClientOptions opts = new ClientOptions();
				opts.id("sender");

				org.apache.qpid.protonj2.client.Client container = org.apache.qpid.protonj2.client.Client.create(opts);
				senderConnection = container.connect("localhost", 61616).openFuture().get();
				org.apache.qpid.protonj2.client.SenderOptions options = new org.apache.qpid.protonj2.client.SenderOptions()
						.deliveryMode(DeliveryMode.AT_MOST_ONCE);
				org.apache.qpid.protonj2.client.Session session = senderConnection.openSession().openFuture().get();
				sender = session.openSender(address, options);
			}

			final org.apache.qpid.protonj2.client.Message<String> message = org.apache.qpid.protonj2.client.Message
					.create("Hello World").durable(true);
			Map<String, Object> deliveryAnnotations = new HashMap<>();
			final org.apache.qpid.protonj2.client.Tracker tracker = sender.send(message, deliveryAnnotations);
			tracker.settlementFuture().isDone();
			tracker.settlementFuture().get().settled();

			/**
			 * Afte waiting some time, re-connect the receiver to the durable subscription.
			 */
			LOGGER.info("Wait for read");
			Thread.sleep(100);

			long receiveTime = new Date().getTime();
			{
				ClientOptions opts = new ClientOptions();
				opts.id("receiver");
				org.apache.qpid.protonj2.client.Client container = org.apache.qpid.protonj2.client.Client.create(opts);
				receiverConnection = container.connect("localhost", 61616).openFuture().get();
				org.apache.qpid.protonj2.client.ReceiverOptions options = new org.apache.qpid.protonj2.client.ReceiverOptions()
						.deliveryMode(DeliveryMode.AT_LEAST_ONCE).autoAccept(false);
				org.apache.qpid.protonj2.client.Session session = receiverConnection.openSession().openFuture().get();

				receiver = session.openDurableReceiver(address, "my-durable-sub", options);
				receiver.openFuture().get(10, TimeUnit.SECONDS);
			}

			/**
			 * Receive a message and ACK it slightly after.
			 */
			Delivery d = receiver.receive();
			LOGGER.info("Wait for ack");
			Thread.sleep(1000);
			long acceptTime = new Date().getTime();
			d.accept();

			sender.closeAsync().get(10, TimeUnit.SECONDS);
			receiver.closeAsync().get(10, TimeUnit.SECONDS);
			receiverConnection.close();
			senderConnection.close();

			/**
			 * Validate that the MessagePublishedMonitoringEvent,
			 * MessageDeliveredMonitoringEvent and MessageAcknowledgedMonitoringEvent are
			 * properly generated
			 */
			assertEquals(3, raisedEvents.size());

			Optional<MessageLifecycleEvent> publishEventOpt = raisedEvents.stream()
					.filter(e -> e.getClass() == MessagePublishedEvent.class).findFirst();
			assertEquals(true, publishEventOpt.isPresent());
			MessagePublishedEvent publishEvent = (MessagePublishedEvent) publishEventOpt.get();

			Optional<MessageLifecycleEvent> deliverEventOpt = raisedEvents.stream()
					.filter(e -> e.getClass() == MessageDeliveredEvent.class).findFirst();
			assertEquals(true, deliverEventOpt.isPresent());
			MessageDeliveredEvent deliverEvent = (MessageDeliveredEvent) deliverEventOpt.get();

			Optional<MessageLifecycleEvent> ackEventOptional = raisedEvents.stream()
					.filter(e -> e.getClass() == MessageAcknowledgedEvent.class).findFirst();
			assertEquals(true, ackEventOptional.isPresent());
			MessageAcknowledgedEvent ackEvent = (MessageAcknowledgedEvent) ackEventOptional.get();

			assertEquals(sender.client().containerId(), publishEvent.clientId);
			assertEquals(address, publishEvent.messageAddress);
			assertEquals(receiver.client().containerId(), deliverEvent.clientId);
			assertEquals(address, deliverEvent.messageAddress);
			assertEquals(publishEvent.messageAddress, deliverEvent.publishAddress);
			assertEquals(publishEvent.clientId, deliverEvent.publishClientId);
			assertEquals(publishEvent.messageId, deliverEvent.messageId);
			// assertEquals(publishEvent.messageSize, deliverEvent.messageSize);
			assertEquals(publishEvent.node, deliverEvent.publishNode);
			assertEquals(publishEvent.timestamp, deliverEvent.publishTimestamp);

			assertTrue(receiveTime < deliverEvent.timestamp);
			assertEquals(publishEvent.timestamp, ackEvent.publishTimestamp);
			assertTrue(acceptTime < ackEvent.timestamp);
		} finally {
			try {
				broker.stop();
			} catch (Exception e) {
			}
		}
	}

	/**
	 * Test that MQTT message flow is properly registered in a clustered
	 * environment. - Create two ActiveMQ brokers (A and B) - Create a consumer on
	 * broker B on "test/atopic" - Create a producer on broker A and send a message
	 * to "test/atopic" - Consumer on broker B receives the message.
	 * 
	 * @throws Exception
	 */
	@Test
	void MQTTTestClustered() throws Exception {

		EmbeddedActiveMQ testBrokerA = null;
		EmbeddedActiveMQ testBrokerB = null;
		try {
			/**
			 * Create a local ActiveMQ server
			 */
			final int brokerAPort = 6161;
			final int brokerBPort = 6162;
			List<MessageLifecycleEvent> raisedEventsBrokerA = new LinkedList<MessageLifecycleEvent>();
			testBrokerA = createActiveMQBroker("test-broker-A", raisedEventsBrokerA, brokerAPort, List.of(brokerBPort));

			List<MessageLifecycleEvent> raisedEventsBrokerB = new LinkedList<MessageLifecycleEvent>();
			testBrokerB = createActiveMQBroker("test-broker-B", raisedEventsBrokerB, brokerBPort,null);

			/**
			 * Create a persistent subscription on a topic. Close the consumer afterwards.
			 */
			String testTopic = "test/atopic";
			IMqttClient consumerBrokerB = new MqttClient("tcp://localhost:" + brokerBPort, "consumer");
			MqttConnectOptions opts = new MqttConnectOptions();
			opts.setCleanSession(true);
			consumerBrokerB.connect(opts);
			consumerBrokerB.setCallback(new MqttCallback() {

				@Override
				public void messageArrived(String topic, MqttMessage message) throws Exception {
					LOGGER.info("messageArrived: " + topic + " " + new String(message.getPayload()));
				}

				@Override
				public void deliveryComplete(IMqttDeliveryToken token) {
					// TODO Auto-generated method stub

				}

				@Override
				public void connectionLost(Throwable cause) {
					// TODO Auto-generated method stub

				}
			});
			consumerBrokerB.subscribe(testTopic, 2);
			/**
			 * Publish a message to the topic
			 */
			IMqttClient publisherBrokerA = new MqttClient("tcp://localhost:" + brokerAPort, "publisher");
			publisherBrokerA.connect();
			MqttMessage message = new MqttMessage("hola from publisher".getBytes());
			message.setQos(2);
			publisherBrokerA.publish(testTopic, message);
			
			Thread.sleep(5 * 1000); // Give some time for consumer to receive messages

			/**
			 * Validate that the MessagePublishedMonitoringEvent,
			 * MessageDeliveredMonitoringEvent and MessageAcknowledgedMonitoringEvent are
			 * properly generated
			 */
			Optional<MessageLifecycleEvent> publishEventOpt = raisedEventsBrokerA.stream()
					.filter(e -> e.getClass() == MessagePublishedEvent.class).findFirst();
			assertEquals(true, publishEventOpt.isPresent());
			MessagePublishedEvent publishEvent = (MessagePublishedEvent) publishEventOpt.get();

			Optional<MessageLifecycleEvent> deliverEventOpt = raisedEventsBrokerB.stream()
					.filter(e -> e.getClass() == MessageDeliveredEvent.class).findFirst();
			assertEquals(true, deliverEventOpt.isPresent());
			MessageDeliveredEvent deliverEvent = (MessageDeliveredEvent) deliverEventOpt.get();

			Optional<MessageLifecycleEvent> ackEventOptional = raisedEventsBrokerB.stream()
					.filter(e -> e.getClass() == MessageAcknowledgedEvent.class).findFirst();
			assertEquals(true, ackEventOptional.isPresent());
			MessageAcknowledgedEvent ackEvent = (MessageAcknowledgedEvent) ackEventOptional.get();

			assertEquals(publishEvent.messageAddress, deliverEvent.publishAddress);
			assertEquals(publishEvent.clientId, deliverEvent.publishClientId);
			assertEquals(publishEvent.messageId, deliverEvent.messageId);
			// assertEquals(publishEvent.messageSize, deliverEvent.messageSize);
			assertEquals(publishEvent.node, deliverEvent.publishNode);
			assertEquals(publishEvent.timestamp, deliverEvent.publishTimestamp);
			// assertTrue(deliverEvent.timestamp > reconnectTime);
			assertEquals(publishEvent.messageId, ackEvent.messageId);
			assertEquals(ackEvent.deliverTimestamp, deliverEvent.timestamp);
			// assertTrue(ackEvent.timestamp > reconnectTime);

		} finally {
			try {
				testBrokerA.stop();
			} catch (Exception e) {
			}
			try {
				testBrokerB.stop();
			} catch (Exception e) {
			}
		}
	}
}
