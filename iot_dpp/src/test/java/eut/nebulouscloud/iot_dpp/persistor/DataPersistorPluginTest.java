package eut.nebulouscloud.iot_dpp.persistor;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.activemq.artemis.api.core.Pair;
import org.apache.activemq.artemis.core.config.Configuration;
import org.apache.activemq.artemis.core.config.impl.ConfigurationImpl;
import org.apache.activemq.artemis.core.security.CheckType;
import org.apache.activemq.artemis.core.security.Role;
import org.apache.activemq.artemis.core.server.embedded.EmbeddedActiveMQ;
import org.apache.activemq.artemis.spi.core.security.ActiveMQSecurityManager;
import org.eclipse.paho.client.mqttv3.IMqttClient;
import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.fasterxml.jackson.databind.ObjectMapper;


public class DataPersistorPluginTest {
	static Logger LOGGER = LoggerFactory.getLogger(DataPersistorPluginTest.class);
	/**
	 * Creates a local ActiveMQ server listening at localhost:61616. The server
	 * accepts requests from any user. Configures the MessageMonitoringPluging and
	 * sets it to store generated events in the provided events list
	 * 
	 * @param events A list that will contain all the events generated by the
	 *               MessageMonitoringPluging
	 * @return the created MessageMonitoringPluging instance.
	 * @throws Exception
	 */
	private EmbeddedActiveMQ createActiveMQBroker(int port, DataPersistorPlugin dataPersistorPlugin) throws Exception {
		Configuration config = new ConfigurationImpl();
		String foldersRoot = "data/" + new Date().getTime() + "/data_" + port;
		config.setBindingsDirectory(foldersRoot + "/bindings");
		config.setJournalDirectory(foldersRoot + "/journal");
		config.setJournalRetentionDirectory(foldersRoot + "/journalRetention");
		config.setLargeMessagesDirectory(foldersRoot + "/lm");
		config.setNodeManagerLockDirectory(foldersRoot + "/nodeManagerLock");
		config.setPagingDirectory(foldersRoot + "/paging");
		config.addAcceptorConfiguration("netty", "tcp://localhost:" + port);
		config.getBrokerMessagePlugins().add(dataPersistorPlugin);

		EmbeddedActiveMQ server = new EmbeddedActiveMQ();
		server.setSecurityManager(new ActiveMQSecurityManager() {
			@Override
			public boolean validateUserAndRole(String user, String password, Set<Role> roles, CheckType checkType) {
				return true;
			}

			@Override
			public boolean validateUser(String user, String password) {
				return true;
			}
		});
		server.setConfiguration(config);
		server.start();
		while (!server.getActiveMQServer().isActive()) {
			System.out.println("Waiting for server to start...");
			Thread.sleep(500);
		}
		return server;
	}
	
	@Test
	public void testExtractors() throws Exception {
		
		assertEquals("a", MessageDataExtractionUtils.regexTransform("a","(.*)","$1"));
		assertEquals("aa", MessageDataExtractionUtils.regexTransform("a","(.*)","$1$1"));
		assertEquals("a-a", MessageDataExtractionUtils.regexTransform("a","(.*)","$1-$1"));
		assertEquals("los", MessageDataExtractionUtils.regexTransform("pepito.los.palotes","pepito\\.(.*)\\.palotes","$1"));
		assertEquals("pepito.palotes", MessageDataExtractionUtils.regexTransform("pepito.los.palotes","(.*)\\.(.*)\\.(.*)","$1.$3"));
		assertEquals("pepito.eldelos.palotes", MessageDataExtractionUtils.regexTransform("pepito.los.palotes","(.*)\\.(.*)\\.(.*)","$1.eldelos.$3"));
		assertEquals("pepito.eldelos.palotes", MessageDataExtractionUtils.evalStringExpression("{ADDRESS|(.*)\\.(.*)\\.(.*)|$1.eldelos.$3}","pepito.los.palotes",null));
		
		assertEquals("address", MessageDataExtractionUtils.evalStringExpression(
				"{ADDRESS|.+\\.([^\\.]*)$|$1}", 
				"super.fancy.address", 
				null
			));
		
		String dict = "{"+
		"name:pepito,"+
		"surname:lospalotes,"+
		"addresses:[\"calle de la piruleta 33\",\"rue de la fua\"]"+
		"}";
		//assertEquals("pepito", MessageDataExtractionUtils.evalStringExpression("{BODY|$.name}",null,dict));
		assertEquals("pepito-lospalotes", MessageDataExtractionUtils.evalStringExpression("{BODY|$.name}-{BODY|$.surname}",null,dict));
		assertEquals("calle de la piruleta 33", MessageDataExtractionUtils.evalStringExpression("{BODY|$.addresses[0]}",null,dict));
		assertEquals("{BODY|$.addresses[3]}", MessageDataExtractionUtils.evalStringExpression("{BODY|$.addresses[3]}",null,dict));
		
		// Additional test scenarios for regex transformations
		assertEquals("", MessageDataExtractionUtils.regexTransform("", "(.*)", "$1")); // Empty string
		assertEquals("123", MessageDataExtractionUtils.regexTransform("abc123def", ".*?(\\d+).*", "$1")); // Extract numbers
		assertEquals("hello-world", MessageDataExtractionUtils.regexTransform("hello world", "(\\w+)\\s+(\\w+)", "$1-$2")); // Word replacement
		//assertEquals("test", MessageDataExtractionUtils.regexTransform("test123", "(\\w+)\\d+", "$1")); // Remove numbers
		assertEquals("original", MessageDataExtractionUtils.regexTransform("original", "nonmatching", "replacement")); // Non-matching pattern
		
		// Additional test scenarios for JSON path extraction
		String complexDict = "{" +
			"user: {" +
				"profile: {" +
					"firstName: John," +
					"lastName: Doe," +
					"age: 30," +
					"addresses: [" +
						"{street: '123 Main St', city: 'New York'}," +
						"{street: '456 Oak Ave', city: 'Boston'}" +
					"]" +
				"}" +
			"}" +
		"}";
		
		assertEquals("John", MessageDataExtractionUtils.evalStringExpression("{BODY|$.user.profile.firstName}", null, complexDict));
		assertEquals("30", MessageDataExtractionUtils.evalStringExpression("{BODY|$.user.profile.age}", null, complexDict));
		assertEquals("123 Main St", MessageDataExtractionUtils.evalStringExpression("{BODY|$.user.profile.addresses[0].street}", null, complexDict));
		assertEquals("Boston", MessageDataExtractionUtils.evalStringExpression("{BODY|$.user.profile.addresses[1].city}", null, complexDict));
		
		// Test combined expressions
		assertEquals("John-Doe-address", MessageDataExtractionUtils.evalStringExpression(
			"{BODY|$.user.profile.firstName}-{BODY|$.user.profile.lastName}-{ADDRESS|.+\\.([^\\.]*)$|$1}", 
			"super.fancy.address", 
			complexDict
		));
		
		// Test non-existent paths
		assertEquals("{BODY|$.user.profile.nonexistent}", 
			MessageDataExtractionUtils.evalStringExpression("{BODY|$.user.profile.nonexistent}", null, complexDict));
		assertEquals("{BODY|$.user.profile.addresses[5]}", 
			MessageDataExtractionUtils.evalStringExpression("{BODY|$.user.profile.addresses[5]}", null, complexDict));
		
		// Test with null dictionary
		assertEquals("{BODY|$.name}", MessageDataExtractionUtils.evalStringExpression("{BODY|$.name}", null, null));
		
		// Test with empty dictionary
		assertEquals("{BODY|$.name}", MessageDataExtractionUtils.evalStringExpression("{BODY|$.name}", null, "{}"));
		
	}
	
	private void assertEequalsKV(List<Pair<String,String>> expected,List<Pair<String,String>> res)
	{
		assertEquals(expected.size(),res.size());
		for(Pair expectedPair:expected)
		{
			boolean found = res.stream().anyMatch(p->p.getA().equals(expectedPair.getA()) && p.getB().equals(expectedPair.getB()));
			
			assertTrue(found);
		}
	}
	
	@Test
	public void testExtractors2() throws Exception {
		String complexDict = "{" +
				"user: {" +
					"profile: {" +
						"firstName: John," +
						"lastName: Doe," +
						"age: 30," +
						"roles: [\"admin\",\"reader\"]," +
						"tags: [" +
						"{k: 'a', v: '1'}," +
						"{k: 'b', v: '2'}" +
						"],"+
						"tags2: [" +
						"{'a': '1'}," +
						"{'b': '2'}" +
						"],"+
						"addresses: [" +
							"{street: '123 Main St', city: 'New York'}," +
							"{street: '456 Oak Ave', city: 'Boston'}" +
						"]" +
					"}" +
				"}" +
			"}";
		{
			List<Pair<String,String>> res =  MessageDataExtractionUtils.evalKVExpression("{BODY|$|$.user.profile.firstName|$.user.profile.lastName}", "", complexDict);
			List<Pair<String,String>> expected = List.of(new Pair<String,String>("John","Doe"));
			assertEequalsKV(expected,res);
		}
		
		{
			List<Pair<String,String>> res =  MessageDataExtractionUtils.evalKVExpression("{BODY|$|$.user.profile.roles[*]|true}", "", complexDict);
			List<Pair<String,String>> expected = List.of(new Pair<String,String>("admin","true"),new Pair<String,String>("reader","true"));
			assertEequalsKV(expected,res);	
		}
		
		{
			List<Pair<String,String>> res =  MessageDataExtractionUtils.evalKVExpression("{BODY|$|$.user.profile.roles[*]|$.user.profile.firstName}", "", complexDict);
			List<Pair<String,String>> expected = List.of(new Pair<String,String>("admin","John"),new Pair<String,String>("reader","John"));
			assertEequalsKV(expected,res);	
		}
		
		{
			List<Pair<String,String>> res =  MessageDataExtractionUtils.evalKVExpression("{BODY|$|$.user.profile.tags[*].k|$.user.profile.tags[*].v}", "", complexDict);
			List<Pair<String,String>> expected = List.of(new Pair<String,String>("a","1"),new Pair<String,String>("b","2"));
			assertEequalsKV(expected,res);	
		}
		
		{
			List<Pair<String,String>> res =  MessageDataExtractionUtils.evalKVExpression("{BODY|$|$.user.profile.tags2[*]}", "", complexDict);
			List<Pair<String,String>> expected = List.of(new Pair<String,String>("a","1"),new Pair<String,String>("b","2"));
			assertEequalsKV(expected,res);	
		}
	}
	
	
	@Test
	public void testTimeExtractor() throws Exception {
	
		{
			String format = "yyyy-MM-dd HH:mm:ss z";
			SimpleDateFormat formatter =new SimpleDateFormat(format);
			Date expected = formatter.parse(formatter.format(new Date()));
			Date res =  MessageDataExtractionUtils.evalTimeExpression("BODY|$.date|"+format, "{'date':'"+formatter.format(expected)+"'}");
			assertEquals(expected.getTime(),res.getTime());
		}
		
		{
			Date expected = new Date();
			Date res =  MessageDataExtractionUtils.evalTimeExpression("BODY|$.date|TIMESTAMP", "{'date':'"+expected.getTime()+"'}");
			assertEquals(expected.getTime(),res.getTime());
		}
		{
			Date expected = new Date();
			Date res =  MessageDataExtractionUtils.evalTimeExpression("BODY|$.date|TIMESTAMP", "{'date':"+expected.getTime()+"}");
			assertEquals(expected.getTime(),res.getTime());
		}
		
	}
	
	
	@Test
	public void testAcceptorExpression() throws Exception {
		String complexDict = "{" +
				"user: {" +
					"profile: {" +
						"firstName: John," +
						"lastName: Doe," +
						"age: 30," +
						"roles: [\"admin\",\"reader\"]," +
						"tags: [" +
						"{k: 'a', v: '1'}," +
						"{k: 'b', v: '2'}" +
						"],"+
						"tags2: [" +
						"{'a': '1'}," +
						"{'b': '2'}" +
						"],"+
						"addresses: [" +
							"{street: '123 Main St', city: 'New York'}," +
							"{street: '456 Oak Ave', city: 'Boston'}" +
						"]" +
					"}" +
				"}" +
			"}";
		{
			
			boolean  res =  MessageDataExtractionUtils.evalAcceptorExpression(".*|$|OR","this.is.a.super.complex.topic", complexDict);
			assertTrue(res);
		}
		
		{
			
			boolean  res =  MessageDataExtractionUtils.evalAcceptorExpression(".*|$|AND","this.is.a.super.complex.topic", complexDict);
			assertTrue(res);
		}
		
		{
			
			boolean  res =  MessageDataExtractionUtils.evalAcceptorExpression(".*|$.pepe|AND","this.is.a.super.complex.topic", complexDict);
			assertFalse(res);
		}
		
		{
			
			boolean  res =  MessageDataExtractionUtils.evalAcceptorExpression(".*|$.pepe|OR","this.is.a.super.complex.topic", complexDict);
			assertTrue(res);
		}
		
		{
			
			boolean  res =  MessageDataExtractionUtils.evalAcceptorExpression("topic|$.[?(@.age<50)]|OR","this.is.a.super.complex.topic", "{age:30}");
			assertTrue(res);
		}
		{
			
			boolean  res =  MessageDataExtractionUtils.evalAcceptorExpression("topic|$.[?(@.age<50)]|OR","this.is.a.super.complex.topic", "{age:50}");
			assertFalse(res);
		}
	}

	@Test
	public void test() throws Exception {
		/*
		 * docker run \ -p 8086:8086 \ -v "$PWD/data:/var/lib/influxdb2" \ -v
		 * "$PWD/config:/etc/influxdb2" \ influxdb:2
		 * 
		 * lK-oWPGUJ25629q5VIFJiX_Y_sZdn3IAeF2YXyLS2siiBMQRTOunkhPOOl55brbO-
		 * CaIOFWVSzqfd1RJxQkWgA== admin adminadmin
		 */

		DataPersistorPlugin dataPersistorPlugin = new DataPersistorPlugin();
		Map<String, String> config = new HashMap<String, String>();
		config.put("influxDB.host", "http://localhost:8086");
		config.put("influxDB.organization", "aaaa");
		config.put("influxDB.token",
				"V6GrKrjnVXC9QZbiyp8KhoSs7z_QLl0uUpxoGUGKOjN0wqAUsv5VZTlgMd4Hv3toCfJ9dM1DTiEG0b0EmZBgjQ==");
		dataPersistorPlugin.init(config);
		EmbeddedActiveMQ broker = createActiveMQBroker(61616, dataPersistorPlugin);
		ObjectMapper om = new ObjectMapper();
		IMqttClient publisher = new MqttClient("tcp://localhost:61616", "publisher");
		publisher.connect();

		while (true) {
			MqttMessage message = new MqttMessage(om.writeValueAsString(Map.of("temperature", 22)).getBytes());
			message.setQos(2);
			publisher.publish("a", message);
			Thread.sleep(1000);
			LOGGER.info("Publish");
		}

	}

}
